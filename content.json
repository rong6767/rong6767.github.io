[{"title":"","date":"2017-04-26T13:42:13.976Z","path":"2017/04/26/为需要动态分配内存的类声明拷贝构造函数是必须的/","text":"为需要动态分配内存的类声明拷贝构造函数是必须的标签： Note 看下面一个表示string对象的类： // 一个很简单的string类 class string { public: string(const char *value); ~string(); ... // 没有拷贝构造函数和operator= private: char *data; }; string::string(const char *value) { if (value) { data = new char[strlen(value) + 1]; strcpy(data, value); } else { data = new char[1]; *data = &apos;\\0&apos;; } } inline string::~string() { delete [] data; } 请注意这个类里没有声明赋值操作符和拷贝构造函数。这会带来一些不良后果。 如果这样定义两个对象： string a(&quot;hello&quot;); string b(&quot;world&quot;); 其结果就会如下所示： a: data——&gt; &quot;hello\\0&quot; b: data——&gt; &quot;world\\0&quot; 对象a的内部是一个指向包含字符串”hello”的内存的指针，对象b的内部是一个指向包含字符串”world”的内存的指针。如果进行下面的赋值： b = a; 因为没有自定义的operator=可以调用，c++会生成并调用一个缺省的operator=操作符（见条款45）。这个缺省的赋值操作符会执行从a的成员到b的成员的逐个成员的赋值操作 这种情况下至少有两个问题。第一，b曾指向的内存永远不会被删除，因而会永远丢失。这是产生内存泄漏的典型例子。第二，现在a和b包含的指针指向同一个字符串，那么只要其中一个离开了它的生存空间，其析构函数就会删除掉另一个指针还指向的那块内存。 拷贝构造函数的情况和赋值操作符还有点不同。在传值调用的时候，它会产生问题。当然正如条款22所说明的，一般很少对对象进行传值调用，但还是看看下面的例子： void donothing(string localstring) {} string s = &quot;the truth is out there&quot;; donothing(s);//缺省拷贝构造函数，直接复制指针，当函数返回时，指针指向的内存被释放 因为被传递的localstring是一个值，它必须从s通过（缺省）拷贝构造函数进行初始化。于是localstring拥有了一个s内的指针的拷贝。当donothing结束运行时，localstring离开了其生存空间，调用析构函数。其结果也将是：s包含一个指向localstring早已删除的内存的指针。 用delete去删除一个已经被删除的指针，其结果是不可预测的。 解决这类指针混乱问题的方案在于，只要类里有指针时，就要写自己版本的拷贝构造函数和赋值操作符函数。在这些函数里，你可以拷贝那些被指向的数据结构，从而使每个对象都有自己的拷贝(深拷贝)；或者你可以采用某种引用计数机制（见条款 m29）去跟踪当前有多少个对象指向某个数据结构。引用计数的方法更复杂，而且它要求构造函数和析构函数内部做更多的工作，但在某些（虽然不是所有）程序里，它会大量节省内存并切实提高速度。","tags":[]},{"title":"","date":"2017-04-16T13:39:04.843Z","path":"2017/04/16/New Blog/","text":"New Blog标签（空格分隔）： 随便写写 This is my first time writing a blog, hope I will not give up on this one, like everything else.","tags":[]},{"title":"Hello World","date":"2017-04-13T09:20:08.209Z","path":"2017/04/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]